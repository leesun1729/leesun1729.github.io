[{"categories":["算法"],"contents":"字典树（TrieTree），是一种树形结构，典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串,如01字典树）。主要思想是利用字符串的公共前缀来节约存储空间。很好地利用了串的公共前缀，节约了存储空间。字典树主要包含两种操作，插入和查找。\nTrieNode形式\n代码 struct Trie { Trie* son[26]; bool isWord; Trie() { for(int i = 0; i \u0026lt; 26; ++i) { son[i] = nullptr; } isWord = false; } ~Trie() { for(int i = 0; i \u0026lt; 26; ++i) { if(son[i] != nullptr) delete son[i]; } } void insert(std::string s) { Trie* node = this; for(char c : s) { int x = c - 'a'; if(node -\u0026gt; son[x] == nullptr) { node -\u0026gt; son[x] = new Trie(); } node = node -\u0026gt; son[x]; } node -\u0026gt; isWord = true; } bool search(std::string s) { Trie* node = this; for(char c : s) { int x = c - 'a'; if(node -\u0026gt; son[x] == nullptr) { return false; } node = node -\u0026gt; son[x]; } return node -\u0026gt; isWord; } bool startsWith(std::string prefix) { Trie* node = this; for(char c : prefix) { int x = c - 'a'; if(node -\u0026gt; son[x] == nullptr) { return false; } node = node -\u0026gt; son[x]; } return true; } };   数组形式\n代码 const int maxn = 1e5 + 10; bool vis[maxn]; int son[maxn][26], idx; struct Trie { Trie() { memset(vis, false, sizeof vis); memset(son, 0, sizeof son); idx = 0; } void insert(std::string word) { int p = 0; for(char c : word) { int u = c - 'a'; if(!son[p][u]) son[p][u] = ++idx; p = son[p][u]; } vis[p] = true; } bool search(std::string word) { int p = 0; for(char c : word) { int u = c - 'a'; if(!son[p][u]) { return false; } p = son[p][u]; } return vis[p]; } bool startsWith(std::string prefix) { int p = 0; for(char c : prefix) { int u = c - 'a'; if(!son[p][u]) { return false; } p = son[p][u]; } return true; } };  ","date":"2024-01-20T22:08:54+08:00","permalink":"https://leesun1729.github.io/post/006-%E5%AD%97%E5%85%B8%E6%A0%91/","tags":["Trie",""],"title":"字典树"},{"categories":["算法"],"contents":"题目链接：CF896C Willem, Chtholly and Seniorious\n题目要求维护一种数据结构，支持以下操作\n将 [l, r] 区间内所有数加上 x\n将 [l, r] 区间内所有数改成 x\n求 [l, r] 区间第 k 小的数\n求 [l, r] 区间内所有数的 x 次方的和取模 y\n用于区间推平操作和数据随机时可以使用这种数据结构\n点击了解更多\n具体实现: 将每个区间 [l, r]上值为 v 定义为一个结点，这里需要将 v 定义为mutable类型，是因为当把 node 结点放入 std::set 中时， 这些对象在 std::set中会被当作 const 对象处理，就不能修改存储在 std::set 中的结构体对象的成员，因为任何尝试改变其中元素的操作都可能影响集合的顺序性质，这样的操作会违反 std::set 的内部机制，但这里我们需要修改的是区间[l, r]上的值即可，有序性是由每个结点的区间的左端点决定，因此将v 定义为mutable类型以方便后续对区间进行修改值\n代码 typedef long long ll; struct node { ll l, r; mutable ll v; // 允许v始终修改 node(ll l, ll r, ll v) : l(l), r(r), v(v) {} friend bool operator \u0026lt; (node x, node y) { return x.l \u0026lt; y.l; } };   c++语法: 这里在结构体内对运算符进行重载，对之后的std::set的排序方式重新定义按照区间左端点排序\n区间划分: 每次添加结点不能保证区间左右端点都在一个结点上，因此需要对结点进行划分，利用std::set集合的有序性，查找第一个大于等于给定位置 pos 的结点，只用考虑两种情况\ncondition1 ： pos 恰好为一个结点的左端点，直接返回\ncondition2 ： pos 小于当前结点的左端点，那么 pos 一定在该结点之前的结点区间内，将这个结点区间[l, r]划分为[l, pos - 1]和 [pos, r]\n代码 std::set\u0026lt;node\u0026gt; tree; // 区间划分 std::set\u0026lt;node\u0026gt; ::iterator split(ll pos) { auto it = tree.lower_bound(node(pos, 0, 0)); if(it != tree.end() \u0026amp;\u0026amp; it -\u0026gt; l == pos) { return it; } it--; ll l = it -\u0026gt; l, r = it -\u0026gt; r, v = it -\u0026gt; v; tree.erase(it); tree.insert(node(l, pos - 1, v)); return tree.insert(node(pos, r, v)).first; }   c++语法: 在这里插入代码片这里tree.insert().first是std::set的一个返回值，当往std::set中插入值时，std::set会返回一个pair对象，第一个元素是一个迭代器，它指向新插入的元素或者一个已经有相同值的元素（因为 std::set 不允许出现重复的元素）。pair 的第二个元素是一个布尔值，指示插入是否发生（如果实际上插入了新元素则为 true，如果一个等效的元素已经存在，则为 false）\n区间赋值: 只要获取要求修改区间左、右端点的结点，把这一段删除，再插入要求赋的值和修改区间的左、右端点作为新的结点，对于新添加的区间[l, r] , 要先split(r + 1) 再 split(l)，即先右后左，否则会编译错误，如果先对左端点进行划分，再对右端点划分可能会对原来左端点划分的结点删除，比如区间[1, 10], 现在要修改左端点 1，右端点8；\n现在先对左端点进行划分，得到左端点所在结点 [1, 10],在对右端点进行划分，得到 [1, 7] , [8, 10] ,原先左端点划分的结点[1, 10]就会被删除，编译报错！\n代码 // 区间赋值 void assign(ll l, ll r, ll v) { auto end = split(r + 1), begin = split(l); tree.erase(begin, end); tree.insert(node(l, r, v)); }   区间第k大数: 暴力求解即可\n代码 // 区间第k大数 ll kth(ll l, ll r, ll k) { auto end = split(r + 1); std::vector\u0026lt; std::pair\u0026lt;ll, ll\u0026gt; \u0026gt; v; for(auto it = split(l); it != end; ++it) { v.emplace_back(it -\u0026gt; v, it -\u0026gt; r - it -\u0026gt; l + 1); } std::sort(v.begin(), v.end()); for(int i = 0; i \u0026lt; v.size(); ++i) { k -= v[i].second; if(k \u0026lt;= 0) { return v[i].first; } } return -1; // error return }   区间幂次求和: 快速幂 + 暴力\n代码 // 快速幂 ll qpow(ll a, ll n, ll mod) { ll res = 1; for( ; n; n \u0026gt;\u0026gt;= 1) { if(n \u0026amp; 1) { res = res * a % mod; } a = a * a % mod; } return res % mod; } // 区间快速幂求和 ll sum_of_pow(ll l, ll r, ll x, ll y) { ll res = 0; auto end = split(r + 1); for(auto it = split(l); it != end; ++it) { res = (res + qpow(it -\u0026gt; v, x, y) * (it -\u0026gt; r - it -\u0026gt; l + 1)) % y; } return res; }  ","date":"2024-01-20T21:59:08+08:00","permalink":"https://leesun1729.github.io/post/005-%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/","tags":["珂朵莉树","线段树"],"title":"珂朵莉树"},{"categories":["算法"],"contents":"强连通分量 SCC (Strongly Connect Component)\n定义 在一个 有向图 中，任意取两个节点(u, v) ，u -\u0026gt; v, v -\u0026gt; u 均有路径，这样的图叫做强连通。\nSCC（强连通分量）：一个极大的强连通子图。\n缩点：当我们求出一个图中的所有 SCC 后，我们可以将每一个 SCC 缩成一个点。缩点过后，我们可以得到一个新的图，我们遍历所有 原图中的边，将原图中的边加到新图中（注意判断 自环，并且一般会出现重复边）。\n 缩点后得到的图一定是一个 DAG（有向无环图）。 DAG 有着很多优秀的性质，比如可以进行 拓扑排序，可以利用 拓扑排序进行 DP 等。  求一个有向图中的强连通分量，有两种算法，Tarjan 与 kosaraju 算法（复杂度均为O(V + E)）。\nTarjan 求有向图的 SCC 算法流程 定义 DFS 树为：从任意节点出发，形成的一条从上往下的生成树。\n当我们从 访问到 direct neighbor v 时，如果 v 尚未被访问过，那么 (u, v) 是一条 树边。否则 (u, v) 是一条 非树边。\n代码 struct SCC { int n; int cnt, cur; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt; \u0026gt; e; std::stack\u0026lt;int\u0026gt; st; // 用于 Tarjan 算法中保存被访问的节点 std::vector\u0026lt;int\u0026gt; dfn, low, f, sz; SCC(int n) { cnt = 0; // 用于计数目前发现的强连通分量个数 cur = 0; // 用作当前访问序号（dfn 的计数） this -\u0026gt; n = n; dfn.assign(n + 1, -1); // 记录节点在 DFS 搜索中的访问顺序 low.assign(n + 1, -1); // 记录在 DFS 过程中每个节点可达的最小 dfn 值 f.assign(n + 1, -1); // 记录每个节点所属的强连通分量的编号 sz.assign(n + 1, 0); // 统计每个强连通分量中包含的节点数 e.assign(n + 1, {}); // 用来存储图的邻接表 } void add_edge(int u, int v) { e[u].push_back(v); } void dfs(int u) { dfn[u] = low[u] = ++cur; st.push(u); for(int v : e[u]) { if(f[v] != -1) continue; if(dfn[v] == -1) { dfs(v); } low[u] = std::min(low[u], low[v]); } if(low[u] == dfn[u]) { cnt++; int x; do { x = st.top(); st.pop(); f[x] = cnt; sz[cnt]++; } while(x != u); } } std::vector\u0026lt;int\u0026gt; work() { for(int i = 1; i \u0026lt;= n; ++i) { if(f[i] == -1) { dfs(i); } } return f; } };   例题： Leetcode 1192. 查找集群内的关键连接\n代码 class Solution { public: int cur = 0; vector\u0026lt;int\u0026gt; dfn, low; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; adj; void tarjan(int u, int fa) { dfn[u] = low[u] = ++cur; for(int v : adj[u]) { if(v == fa) continue; if(!dfn[v]) { tarjan(v, u); low[u] = min(low[u], low[v]); if(dfn[u] \u0026lt; low[v]) { res.push_back({u, v}); } } else { low[u] = min(low[u], dfn[v]); } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; criticalConnections(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; connections) { dfn.resize(n); low.resize(n); adj.resize(n); for(auto \u0026amp;e : connections) { adj[e[0]].push_back(e[1]); adj[e[1]].push_back(e[0]); } for(int i = 0; i \u0026lt; n; ++i) { if(!dfn[i]) { tarjan(i, -1); } } return res; } };   例题：洛谷P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; struct SCC { int n; int cnt, cur; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt; \u0026gt; e; std::stack\u0026lt;int\u0026gt; st; // 用于 Tarjan 算法中保存被访问的节点 std::vector\u0026lt;int\u0026gt; dfn, low, f, sz; SCC(int n) { cnt = 0; // 用于计数目前发现的强连通分量个数 cur = 0; // 用作当前访问序号（dfn 的计数） this -\u0026gt; n = n; dfn.assign(n + 1, -1); // 记录节点在 DFS 搜索中的访问顺序 low.assign(n + 1, -1); // 记录在 DFS 过程中每个节点可达的最小 dfn 值 f.assign(n + 1, -1); // 记录每个节点所属的强连通分量的编号 sz.assign(n + 1, 0); // 统计每个强连通分量中包含的节点数 e.assign(n + 1, {}); // 用来存储图的邻接表 } void add_edge(int u, int v) { e[u].push_back(v); } void dfs(int u) { dfn[u] = low[u] = ++cur; st.push(u); for(int v : e[u]) { if(f[v] != -1) continue; if(dfn[v] == -1) { dfs(v); } low[u] = std::min(low[u], low[v]); } if(low[u] == dfn[u]) { cnt++; int x; do { x = st.top(); st.pop(); f[x] = cnt; sz[cnt]++; } while(x != u); } } std::vector\u0026lt;int\u0026gt; work() { for(int i = 1; i \u0026lt;= n; ++i) { if(f[i] == -1) { dfs(i); } } return f; } }; int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; SCC g(n); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt; \u0026gt; adj(n + 1); for(int i = 0; i \u0026lt; m; ++i) { int a, b; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; adj[a].push_back(b); g.add_edge(a, b); } std::vector\u0026lt;int\u0026gt; f = g.work(); std::vector\u0026lt;int\u0026gt; deg(n + 1); for(int i = 1; i \u0026lt;= n; ++i) { for(int v : adj[i]) { if(f[i] != f[v]) { deg[f[i]]++; } } } int ans = 0; for(int i = 1; i \u0026lt;= g.cnt; ++i) { if(!deg[i]) { if(ans) { std::cout \u0026lt;\u0026lt; \u0026quot;0\\n\u0026quot;; return 0; } ans = i; } } std::cout \u0026lt;\u0026lt; g.sz[ans] \u0026lt;\u0026lt; '\\n'; return 0; }   模版题：洛谷P2863 [USACO06JAN]The Cow Prom S\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; struct SCC { int n; int cnt, cur; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt; \u0026gt; e; std::stack\u0026lt;int\u0026gt; st; // 用于 Tarjan 算法中保存被访问的节点 std::vector\u0026lt;int\u0026gt; dfn, low, f, sz, vis; SCC(int n) { cnt = 0; // 用于计数目前发现的强连通分量个数 cur = 0; // 用作当前访问序号（dfn 的计数） this -\u0026gt; n = n; dfn.assign(n + 1, -1); // 记录节点在 DFS 搜索中的访问顺序 low.assign(n + 1, -1); // 记录在 DFS 过程中每个节点可达的最小 dfn 值 f.assign(n + 1, -1); // 记录每个节点所属的强连通分量的编号 sz.assign(n + 1, 0); // 统计每个强连通分量中包含的节点数 e.assign(n + 1, {}); // 用来存储图的邻接表 } void add_edge(int u, int v) { e[u].push_back(v); } void dfs(int u) { dfn[u] = low[u] = ++cur; st.push(u); for(int v : e[u]) { if(f[v] != -1) continue; if(dfn[v] == -1) { dfs(v); } low[u] = std::min(low[u], low[v]); } if(low[u] == dfn[u]) { cnt++; int x; do { x = st.top(); st.pop(); f[x] = cnt; sz[cnt]++; } while(x != u); } } void work() { for(int i = 1; i \u0026lt;= n; ++i) { if(f[i] == -1) { dfs(i); } } } }; int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; SCC g(n); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt; \u0026gt; adj(n + 1); for(int i = 0; i \u0026lt; m; ++i) { int a, b; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; adj[a].push_back(b); g.add_edge(a, b); } g.work(); int ans = 0; for(int i = 1; i \u0026lt;= g.cnt; ++i) { if(g.sz[i] \u0026gt; 1) ans++; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; '\\n'; return 0; }  ","date":"2024-01-20T21:55:56+08:00","permalink":"https://leesun1729.github.io/post/004-scc/","tags":["SCC","Tarjan"],"title":"SCC"},{"categories":["C++"],"contents":"内部实现 priority_queue 在 C++ 标准模板库 (STL) 中是一个容器适配器，它提供了优先队列的功能。它允许用户从集合中高效地添加新元素、移除最大元素（或根据提供的比较函数决定的“顶部”元素），以及得到顶部元素的值而不移除它。它不是一个完整的容器类，而是一个构建在某个实际容器之上的适配器，默认情况下，底层容器通常是std::vector。它的内部实现是基于堆数据结构的。\npriority_queue关键概念和实现的概述：\n 底层容器: priority_queue 使用一个可随机访问的容器作为其底层数据结构，并在此容器上实现一个堆。默认容器是std::vector，但你可以使用任何可随机访问的容器，比如std::deque。你不能直接操作这个容器，因为priority_queue仅公开了与队列相关的接口。 堆操作: 内部实现中的核心是堆操作算法，比如std::make_heap, std::push_heap, 和 std::pop_heap，这些算法定义在 \u0026lt;algorithm\u0026gt; 头文件中。当你添加或删除元素时，priority_queue 使用这些算法保持元素的正确排序。  std::make_heap: 将底层容器中的元素构建成一个堆，这通常在构造priority_queue时调用一次。 std::push_heap: 当新元素被添加到底层容器的末尾时，这个算法调整元素来维持堆的性质。 std::pop_heap: 当顶部元素被移除时，这个算法将堆底的元素移到顶部，然后重排堆以保持堆的顺序。   堆的性质: 自堆是一个完全二叉树，一般用数组来表示。对一个最大堆来说，每个节点的值都大于或等于其子节点的值。对于最小堆（通过提供std::greater比较函数或其他方式来实现），则正好相反，每个节点的值都小于或等于其子节点的值。 访问顶部元素: 由于堆的性质，堆顶的元素总是位于底层容器的begin()位置，priority_queue的top()方法就是返回这个位置的元素。 添加和删除元素:  添加元素：调用push()方法，则元素被添加到底层容器的末尾（这是由于底层容器通常是std::vector），然后算法std::push_heap被调用，以重新排列元素维持堆的顺序。 删除元素：调用pop()方法，std::pop_heap先被调用，并将顶部元素与底部元素交换，然后从容器中移除末尾的元素（之前的堆顶），最后保持堆的性质。   比较器函数: priority_queue 允许用户提供一个可选的比较函数来自定义元素的优先级。如果不提供，将使用std::less来建立一个最大堆。提供std::greater作为比较器会建立一个最小堆。  priority_queue: O( 1 ) 获取最大（或最小）元素，并以 O(logn) 添加和移除元素\n优先队列基本操作 / 用法 代码 q.empty(); 队列为空返回1 q.pop(); 出队 q.push(); 入队 q.top(); 返回队列中优先级最高的元素 q.size(); 返回队列中元素的个数   代码 // 默认优先队列 priority_queue 是最大堆 priority_queue\u0026lt;int\u0026gt; q; q.push(1); // q : 1 q.push(2); // q : 2 , 1 q.push(3); // q : 3 , 2 , 1 cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; '\\n'; // 3 q.pop(); cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; '\\n'; // 2 q.pop(); cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; '\\n'; // 1   代码 //定义优先级队列q，less表示按照递减(从大到小)的顺序插入元素，与默认情况相同 priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,less\u0026lt;int\u0026gt;\u0026gt; q; //定义优先级队列q，greater表示按照递增（从小到大）的顺序插入元素 priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; q;   关于优先队列重载运算符 代码 struct point{ int x; int y; int times; friend bool operator \u0026lt; (point a, point b) { return a.times \u0026gt; b.times; //重载小于号使得小的先出队列 } }; // 默认情况下，队列中应按从大到小排序 priority_queue\u0026lt;point\u0026gt; q; // 在此处定义一个优先队列priority_queue\u0026lt;point\u0026gt; q; // 如果要按照以times进行从小到大排列，操作如上。进行重载 \u0026lt; 操作符。 // 意思是如果a.times \u0026gt; b.times成立，那么结构体point a \u0026lt; point b成立。 // 由于优先队列是按照从大到小排列，所以结构体b会排列到a之前，然而b.times是最小的， // 所以实现了按照times的从小到大排序   结构体内部 方式一\n代码 struct Point { int x, y; // 为两个结构体参数，结构体调用一定要写上friend friend bool operator \u0026lt; (Point a, Point b) { if(a.x == b.x) return a.y \u0026lt; b.y; return a.x \u0026lt; b.x; // 按x从小到大排 } };   方式二\n代码 struct Point { int x, y; // 直接传入一个参数，不必要写friend bool operator \u0026lt; (const Point \u0026amp;a) const { if(x == a.x) return y \u0026lt; a.y; return x \u0026lt; a.x; // 按x升序排列 } };   优先队列在内部通常使用堆（heap）数据结构，而最常见的形式是最大堆和最小堆。在C++的标准库实现中，std::priority_queue 默认为一个最大堆。这意味着队列的顶部（即队列的top()方法返回的元素）是所有元素中“最大”的元素。更具体地说，如果没有指明比较方式，优先队列使用std::less类型作为内部比较对象，该对象使用元素类型的\u0026lt;运算符来决定元素的顺序。\n那么为何重载\u0026lt;而不是\u0026gt;？在C++中，重载\u0026lt;运算符有一些传统和实际的原因：\n 符合排序习惯：通常，排序算法和容器使用\u0026lt;运算符来确定顺序，列表或数组的“自然排序”通常是升序。 简洁的默认行为：重载\u0026lt;运算符使得用户不需要指定额外的比较函数就能直接使用标准库的容器和算法，如std::sort, std::set, std::map等。 兼容性：对于标准库中的容器，默认情况下都是使用\u0026lt;来排序的。因此，为了统一，重载\u0026lt;可以使自定义类型与这些容器无缝配合。 最小化重载的需求：在C++中，如果你重载了\u0026lt;运算符，那么你可以用std::less(默认)和std::greater这两个标准库提供的比较函数对象来创建最小堆和最大堆。而如果你只重载了\u0026gt;运算符，你不能直接使用std::less，因为它依赖\u0026lt;运算符。  对于std::priority_queue来说，如果你想要改变排序行为创建一个最小堆（小的元素优先），你可以这样重载\u0026lt;：\n代码 bool operator\u0026lt;(const node \u0026amp;other) const { return val \u0026gt; other.val; // 对于优先队列来说，这样会让小值优先 }   或者，你可以使用一个自定义的比较类型：\n代码 struct CompareNode { bool operator()(const node\u0026amp; n1, const node\u0026amp; n2) { return n1.val \u0026gt; n2.val; // 也是小值优先 } }; std::priority_queue\u0026lt;node, std::vector\u0026lt;node\u0026gt;, CompareNode\u0026gt; queue;   这种做法的一个好处是，代码的意图非常清晰 —— 你看到比较函数时就能立刻知道队列是如何排序的。而且，它使得类型的常规\u0026lt;运算符保持按照字面“小于”的意义，这有助于保持代码直观和一致。\n结构体外部 代码 //定义的比较结构体 //注意：cmp是个结构体 struct cmp {//自定义排序规则 bool operator()(const Point\u0026amp; a,const Point\u0026amp; b) { if(a.x == b.x) return a.y \u0026lt; b.y; return a.x \u0026lt; b.x; //将小于号比较规则替换为结构体x比较规则 }//如果要升序改变不等号方向就好 }; //初始化定义 priority_queue\u0026lt;Point,vector\u0026lt;Point\u0026gt;, cmp\u0026gt; q;   函数自定义排序规则，可以出现在sort排序中 代码 struct Point { int x, y; }p[1005]; bool cmp(Point a, Point b) { if(a.x == b.x) return a.y \u0026lt; b.y; return a.x \u0026lt; b.x; } sort(p + 1, p + 1 + 1000, cmp);   函数自定义排序规则，可以直接出现在sort排序中 代码 struct Point { int x, y; }p[1005]; // 方式一 sort(p + 1, p + 1 + 1000, [](const Point \u0026amp;p1, const Point \u0026amp;p2){ return p1.x \u0026lt; p2.x; }); // 方式二， [\u0026amp;]：取地址符，作用是引用sort之外的其他变量，在函数比较中， // 如果需要用到sort之外的变量可使用[\u0026amp;]来直接使用 sort(p + 1, p + 1 + 1000, [\u0026amp;](const Point \u0026amp;p1, const Point \u0026amp;p2){ return p1.x \u0026lt; p2.x; }); const int N = 1005; std::vector\u0026lt;Point\u0026gt; P(N); // STL容器的两种写法 sort(P.begin(), P.end(), [](const Point \u0026amp;p1, const Point \u0026amp;p2){ return p1.x \u0026lt; p2.x; }); sort(begin(P), end(P), [](const Point \u0026amp;p1, const Point \u0026amp;p2){ return p1.x \u0026lt; p2.x; });  ","date":"2024-01-20T21:50:09+08:00","permalink":"https://leesun1729.github.io/post/003-c++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","tags":["优先队列","运算符重载"],"title":"C++运算符重载"},{"categories":["算法"],"contents":"快捷键  ctrl+b (OSX) complie and run ctrl+enter new test ctrl+c (OSX) kill process ctrl+shift+b (OSX) run with debugger ctrl+d delete test ctrl+super+up/ctrl+super+down (OSX) swap tests cmd+k, cmd+p (OSX) close/open right panel  Settings  To edit settings   press and type FastOlympicCoding: Open Settings\ncmd+shift+p (OSX)\n  or Preferences — Package Settings — FastOlympicCoding\n    ","date":"2024-01-20T21:44:49+08:00","permalink":"https://leesun1729.github.io/post/002-sublimt-text4/","tags":["sublimt text4","FastOlympicCode"],"title":"Sublimt Text4"},{"categories":["工程"],"contents":"前述 网站构成: hugo + even + github actions , 参考资料:\n https://ouuan.github.io/post/from-hexo-to-hugo/\n 搭建过程 Step 1 引自tom0727的搭建指南 首先阅读ouuan的指南，然后使用他的hugo模版，按照模版里指示的进行clone\nStep 2 Config的修改 还是按照模版里指示的，修改一下配置文件config.toml里的相关配置，一些需要更改的内容：\n 包含yourname的部分 newContentEditor = \u0026quot;\u0026quot; defaultContentLanguage = \u0026quot;en\u0026quot; [[menu.main]]的相关内容 (视情况进行保留和删除) 不要更改 [params] 中的 version=\u0026quot;4.x\u0026quot;  注:这里还有一个需要注意的，执行命令hugo server会出现报错，因为现在不支持google_news.html,解决办法删除目录hugo/themes/even/layouts/partials/head.html的{{- template \u0026quot;_internal/google_news.html\u0026quot; . -}},相关讨论\nStep 2.5 创建repository 因为我打算部署到github pages上，就在github上创建一个新的repository，叫leesun1729.github.io\ngit init git add . git commit -m \u0026quot;first commit\u0026quot; git remote add origin https://github.com/leesun1729/leesun1729.github.io.git git branch -M master git push -u origin master  Step 3 本地测试 配置完成后，可以 hugo new post/test.md 创建一个新的post(在hugo-blog/content/post/test.md), 按照markdown随便写点东西以后保存，然后 hugo server，打开localhost看一下效果 最后用hugo --theme=even --baseURL=\u0026quot;https://leesun1729.github.io/\u0026quot; --buildDrafts命令生成静态文件，就是hugo-blog/public/文件夹，把这个文件夹内的内容push到github上就可以了\ncd public git init git add . git commit -m \u0026quot;first commit\u0026quot; git remote add origin https://github.com/leesun1729/leesun1729.github.io.git git branch -M publish git push -u origin publish  注： blog的源代码和网页内容并不是一个东西!\n 源代码: 是hugo-blog/ 下除了hugo-blog/public/以外的内容，包含了 content/, config.toml 之类的文件。 网页内容：只是 hugo-blog/public/内的内容，有了源代码就可以用hugo生成网页内容，但是反之就不可以！  既然两者有别，就要分开管理，我把它们放在同一个repository里，分成2个branch。源代码就放在了master里，网页内容就放在publish上了。\nStep 4 Github Settings 这个时候网页上应该是没有内容的，因为github pages需要设置一下指定deploy的branch，在repository的Settings里，拉到下面看到GitHub Pages，改一下Source branch就可以了：  需要在博文里插入图片的话，假设图片位于 static/images/001/1.png，就写上![image](/images/001/1.png)\n如果是插入link的话，就写 [link_name](https://...) 即可，外部链接记得加https://，不然会被当作本地的某个文件位置。\n 这些步骤做完就可以了，当然这种修改然后发布的方式太麻烦了，切branch也很累，所以就有了Step 5:\nStep 5 Github Actions 我们配置一下Github actions，它能自动化部署流程。参考资料:\n https://segmentfault.com/a/1190000021815477\n 需要注意，因为源代码和网页内容在同一个repository里，就不用在github上折腾secret key之类的了，直接修改一下 hugo-blog/.github/workflows/deploy.yml (这个是template里自带的) 即可：\n personal_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: publish 将 depth 改成 fetch-depth (不然build的时候会报错)  这样就完成了，从此以后，写一篇新文章的步骤就变成：\n hugo new post/article.md 修改位于content/post/article.md的博客文章 add, commit, 把源代码push到master  这样就可以了，不必切branch然后push网页内容了。\nStep 6 其他 更多内容请参考tom0727的搭建指南\n","date":"2024-01-20T21:06:30+08:00","permalink":"https://leesun1729.github.io/post/001-hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0/","tags":["hugo","博客"],"title":"Hugo博客搭建记"},{"categories":[""],"contents":"Hello, this is Leesun! About me  A college student   Contact  Email: leesun1729@gmail.com QQ/Wechat: 746671499  ","date":"2024-01-20T21:05:36+08:00","permalink":"https://leesun1729.github.io/about/","tags":["",""],"title":"About"},{"categories":null,"contents":"","date":"2024-01-20T21:04:20+08:00","permalink":"https://leesun1729.github.io/search/","tags":null,"title":"搜索"},{"categories":[""],"contents":"友情链接 ","date":"2024-01-20T21:00:56+08:00","permalink":"https://leesun1729.github.io/links/","tags":["",""],"title":"Links"}]