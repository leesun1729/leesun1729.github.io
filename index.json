[{"categories":["C++"],"contents":"内部实现 priority_queue 在 C++ 标准模板库 (STL) 中是一个容器适配器，它提供了优先队列的功能。它允许用户从集合中高效地添加新元素、移除最大元素（或根据提供的比较函数决定的“顶部”元素），以及得到顶部元素的值而不移除它。它不是一个完整的容器类，而是一个构建在某个实际容器之上的适配器，默认情况下，底层容器通常是std::vector。它的内部实现是基于堆数据结构的。\npriority_queue关键概念和实现的概述：\n 底层容器: priority_queue 使用一个可随机访问的容器作为其底层数据结构，并在此容器上实现一个堆。默认容器是std::vector，但你可以使用任何可随机访问的容器，比如std::deque。你不能直接操作这个容器，因为priority_queue仅公开了与队列相关的接口。 堆操作: 内部实现中的核心是堆操作算法，比如std::make_heap, std::push_heap, 和 std::pop_heap，这些算法定义在 \u0026lt;algorithm\u0026gt; 头文件中。当你添加或删除元素时，priority_queue 使用这些算法保持元素的正确排序。  std::make_heap: 将底层容器中的元素构建成一个堆，这通常在构造priority_queue时调用一次。 std::push_heap: 当新元素被添加到底层容器的末尾时，这个算法调整元素来维持堆的性质。 std::pop_heap: 当顶部元素被移除时，这个算法将堆底的元素移到顶部，然后重排堆以保持堆的顺序。   堆的性质: 自堆是一个完全二叉树，一般用数组来表示。对一个最大堆来说，每个节点的值都大于或等于其子节点的值。对于最小堆（通过提供std::greater比较函数或其他方式来实现），则正好相反，每个节点的值都小于或等于其子节点的值。 访问顶部元素: 由于堆的性质，堆顶的元素总是位于底层容器的begin()位置，priority_queue的top()方法就是返回这个位置的元素。 添加和删除元素:  添加元素：调用push()方法，则元素被添加到底层容器的末尾（这是由于底层容器通常是std::vector），然后算法std::push_heap被调用，以重新排列元素维持堆的顺序。 删除元素：调用pop()方法，std::pop_heap先被调用，并将顶部元素与底部元素交换，然后从容器中移除末尾的元素（之前的堆顶），最后保持堆的性质。   比较器函数: priority_queue 允许用户提供一个可选的比较函数来自定义元素的优先级。如果不提供，将使用std::less来建立一个最大堆。提供std::greater作为比较器会建立一个最小堆。  priority_queue: O( 1 ) 获取最大（或最小）元素，并以 O(logn) 添加和移除元素\n优先队列基本操作 / 用法 q.empty(); 队列为空返回1 q.pop(); 出队 q.push(); 入队 q.top(); 返回队列中优先级最高的元素 q.size(); 返回队列中元素的个数  // 默认优先队列 priority_queue 是最大堆 priority_queue\u0026lt;int\u0026gt; q; q.push(1); // q : 1 q.push(2); // q : 2 , 1 q.push(3); // q : 3 , 2 , 1 cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; '\\n'; // 3 q.pop(); cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; '\\n'; // 2 q.pop(); cout \u0026lt;\u0026lt; q.top() \u0026lt;\u0026lt; '\\n'; // 1  //定义优先级队列q，less表示按照递减(从大到小)的顺序插入元素，与默认情况相同 priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,less\u0026lt;int\u0026gt;\u0026gt; q; //定义优先级队列q，greater表示按照递增（从小到大）的顺序插入元素 priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; q;  关于优先队列重载运算符 struct point{ int x; int y; int times; friend bool operator \u0026lt; (point a, point b) { return a.times \u0026gt; b.times; //重载小于号使得小的先出队列 } }; // 默认情况下，队列中应按从大到小排序 priority_queue\u0026lt;point\u0026gt; q; // 在此处定义一个优先队列priority_queue\u0026lt;point\u0026gt; q; // 如果要按照以times进行从小到大排列，操作如上。进行重载 \u0026lt; 操作符。 // 意思是如果a.times \u0026gt; b.times成立，那么结构体point a \u0026lt; point b成立。 // 由于优先队列是按照从大到小排列，所以结构体b会排列到a之前，然而b.times是最小的， // 所以实现了按照times的从小到大排序  结构体内部 方式一\nstruct Point { int x, y; // 为两个结构体参数，结构体调用一定要写上friend friend bool operator \u0026lt; (Point a, Point b) { if(a.x == b.x) return a.y \u0026lt; b.y; return a.x \u0026lt; b.x; // 按x从小到大排 } };  方式二\nstruct Point { int x, y; // 直接传入一个参数，不必要写friend bool operator \u0026lt; (const Point \u0026amp;a) const { if(x == a.x) return y \u0026lt; a.y; return x \u0026lt; a.x; // 按x升序排列 } };    Notion\n优先队列在内部通常使用堆（heap）数据结构，而最常见的形式是最大堆和最小堆。在C++的标准库实现中，std::priority_queue 默认为一个最大堆。这意味着队列的顶部（即队列的top()方法返回的元素）是所有元素中“最大”的元素。更具体地说，如果没有指明比较方式，优先队列使用std::less类型作为内部比较对象，该对象使用元素类型的\u0026lt;运算符来决定元素的顺序。\n那么为何重载\u0026lt;而不是\u0026gt;？在C++中，重载\u0026lt;运算符有一些传统和实际的原因：\n 符合排序习惯：通常，排序算法和容器使用\u0026lt;运算符来确定顺序，列表或数组的“自然排序”通常是升序。 简洁的默认行为：重载\u0026lt;运算符使得用户不需要指定额外的比较函数就能直接使用标准库的容器和算法，如std::sort, std::set, std::map等。 兼容性：对于标准库中的容器，默认情况下都是使用\u0026lt;来排序的。因此，为了统一，重载\u0026lt;可以使自定义类型与这些容器无缝配合。 最小化重载的需求：在C++中，如果你重载了\u0026lt;运算符，那么你可以用std::less(默认)和std::greater这两个标准库提供的比较函数对象来创建最小堆和最大堆。而如果你只重载了\u0026gt;运算符，你不能直接使用std::less，因为它依赖\u0026lt;运算符。  对于std::priority_queue来说，如果你想要改变排序行为创建一个最小堆（小的元素优先），你可以这样重载\u0026lt;：\nbool operator\u0026lt;(const node \u0026amp;other) const { return val \u0026gt; other.val; // 对于优先队列来说，这样会让小值优先 }  或者，你可以使用一个自定义的比较类型：\nstruct CompareNode { bool operator()(const node\u0026amp; n1, const node\u0026amp; n2) { return n1.val \u0026gt; n2.val; // 也是小值优先 } }; std::priority_queue\u0026lt;node, std::vector\u0026lt;node\u0026gt;, CompareNode\u0026gt; queue;  这种做法的一个好处是，代码的意图非常清晰 —— 你看到比较函数时就能立刻知道队列是如何排序的。而且，它使得类型的常规\u0026lt;运算符保持按照字面“小于”的意义，这有助于保持代码直观和一致。\n  结构体外部 //定义的比较结构体 //注意：cmp是个结构体 struct cmp {//自定义排序规则 bool operator()(const Point\u0026amp; a,const Point\u0026amp; b) { if(a.x == b.x) return a.y \u0026lt; b.y; return a.x \u0026lt; b.x; //将小于号比较规则替换为结构体x比较规则 }//如果要升序改变不等号方向就好 }; //初始化定义 priority_queue\u0026lt;Point,vector\u0026lt;Point\u0026gt;, cmp\u0026gt; q;  函数自定义排序规则，可以出现在sort排序中 struct Point { int x, y; }p[1005]; bool cmp(Point a, Point b) { if(a.x == b.x) return a.y \u0026lt; b.y; return a.x \u0026lt; b.x; } sort(p + 1, p + 1 + 1000, cmp);  函数自定义排序规则，可以直接出现在sort排序中 struct Point { int x, y; }p[1005]; // 方式一 sort(p + 1, p + 1 + 1000, [](const Point \u0026amp;p1, const Point \u0026amp;p2){ return p1.x \u0026lt; p2.x; }); // 方式二， [\u0026amp;]：取地址符，作用是引用sort之外的其他变量，在函数比较中， // 如果需要用到sort之外的变量可使用[\u0026amp;]来直接使用 sort(p + 1, p + 1 + 1000, [\u0026amp;](const Point \u0026amp;p1, const Point \u0026amp;p2){ return p1.x \u0026lt; p2.x; }); const int N = 1005; std::vector\u0026lt;Point\u0026gt; P(N); // STL容器的两种写法 sort(P.begin(), P.end(), [](const Point \u0026amp;p1, const Point \u0026amp;p2){ return p1.x \u0026lt; p2.x; }); sort(begin(P), end(P), [](const Point \u0026amp;p1, const Point \u0026amp;p2){ return p1.x \u0026lt; p2.x; });  ","date":"2024-01-20T21:50:09+08:00","permalink":"https://leesun1729.github.io/post/003-c++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","tags":["优先队列","运算符重载"],"title":"003 C++运算符重载"},{"categories":["算法"],"contents":"快捷键  ctrl+b (OSX) complie and run ctrl+enter new test ctrl+c (OSX) kill process ctrl+shift+b (OSX) run with debugger ctrl+d delete test ctrl+super+up/ctrl+super+down (OSX) swap tests cmd+k, cmd+p (OSX) close/open right panel  Settings  To edit settings   press and type FastOlympicCoding: Open Settings\ncmd+shift+p (OSX)\n  or Preferences — Package Settings — FastOlympicCoding\n    ","date":"2024-01-20T21:44:49+08:00","permalink":"https://leesun1729.github.io/post/002-sublimt-text4/","tags":["sublimt text4","FastOlympicCode"],"title":"002 Sublimt Text4"},{"categories":["工程"],"contents":"前述 网站构成: hugo + even + github actions , 参考资料:\n https://ouuan.github.io/post/from-hexo-to-hugo/\n 搭建过程 Step 1 引自tom0727的搭建指南 首先阅读ouuan的指南，然后使用他的hugo模版，按照模版里指示的进行clone\nStep 2 Config的修改 还是按照模版里指示的，修改一下配置文件config.toml里的相关配置，一些需要更改的内容：\n 包含yourname的部分 newContentEditor = \u0026quot;\u0026quot; defaultContentLanguage = \u0026quot;en\u0026quot; [[menu.main]]的相关内容 (视情况进行保留和删除) 不要更改 [params] 中的 version=\u0026quot;4.x\u0026quot;  注:这里还有一个需要注意的，执行命令hugo server会出现报错，因为现在不支持google_news.html,解决办法删除目录hugo/themes/even/layouts/partials/head.html的{{- template \u0026quot;_internal/google_news.html\u0026quot; . -}},相关讨论\nStep 2.5 创建repository 因为我打算部署到github pages上，就在github上创建一个新的repository，叫leesun1729.github.io\ngit init git add . git commit -m \u0026quot;first commit\u0026quot; git remote add origin https://github.com/leesun1729/leesun1729.github.io.git git branch -M master git push -u origin master  Step 3 本地测试 配置完成后，可以 hugo new post/test.md 创建一个新的post(在hugo-blog/content/post/test.md), 按照markdown随便写点东西以后保存，然后 hugo server，打开localhost看一下效果 最后用hugo --theme=even --baseURL=\u0026quot;https://leesun1729.github.io/\u0026quot; --buildDrafts命令生成静态文件，就是hugo-blog/public/文件夹，把这个文件夹内的内容push到github上就可以了\ncd public git init git add . git commit -m \u0026quot;first commit\u0026quot; git remote add origin https://github.com/leesun1729/leesun1729.github.io.git git branch -M publish git push -u origin publish  注： blog的源代码和网页内容并不是一个东西!\n 源代码: 是hugo-blog/ 下除了hugo-blog/public/以外的内容，包含了 content/, config.toml 之类的文件。 网页内容：只是 hugo-blog/public/内的内容，有了源代码就可以用hugo生成网页内容，但是反之就不可以！  既然两者有别，就要分开管理，我把它们放在同一个repository里，分成2个branch。源代码就放在了master里，网页内容就放在publish上了。\nStep 4 Github Settings 这个时候网页上应该是没有内容的，因为github pages需要设置一下指定deploy的branch，在repository的Settings里，拉到下面看到GitHub Pages，改一下Source branch就可以了：  需要在博文里插入图片的话，假设图片位于 static/images/001/1.png，就写上![image](/images/001/1.png)\n如果是插入link的话，就写 [link_name](https://...) 即可，外部链接记得加https://，不然会被当作本地的某个文件位置。\n 这些步骤做完就可以了，当然这种修改然后发布的方式太麻烦了，切branch也很累，所以就有了Step 5:\nStep 5 Github Actions 我们配置一下Github actions，它能自动化部署流程。参考资料:\n https://segmentfault.com/a/1190000021815477\n 需要注意，因为源代码和网页内容在同一个repository里，就不用在github上折腾secret key之类的了，直接修改一下 hugo-blog/.github/workflows/deploy.yml (这个是template里自带的) 即可：\n personal_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: publish 将 depth 改成 fetch-depth (不然build的时候会报错)  这样就完成了，从此以后，写一篇新文章的步骤就变成：\n hugo new post/article.md 修改位于content/post/article.md的博客文章 add, commit, 把源代码push到master  这样就可以了，不必切branch然后push网页内容了。\nStep 6 其他 更多内容请参考tom0727的搭建指南\n","date":"2024-01-20T21:06:30+08:00","permalink":"https://leesun1729.github.io/post/001-hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0/","tags":["hugo","博客"],"title":"Hugo博客搭建记"},{"categories":[""],"contents":"Hello, this is Leesun! About me  A college student   Contact  Email: leesun1729@gmail.com QQ/Wechat: 746671499  ","date":"2024-01-20T21:05:36+08:00","permalink":"https://leesun1729.github.io/about/","tags":["",""],"title":"About"},{"categories":null,"contents":"","date":"2024-01-20T21:04:20+08:00","permalink":"https://leesun1729.github.io/search/","tags":null,"title":"搜索"},{"categories":[""],"contents":"友情链接 ","date":"2024-01-20T21:00:56+08:00","permalink":"https://leesun1729.github.io/links/","tags":["",""],"title":"Links"}]